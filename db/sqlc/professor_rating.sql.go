// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: professor_rating.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createProfessorCourseAssociation = `-- name: CreateProfessorCourseAssociation :exec
INSERT INTO professor_course_associations (
  course_code,
  professor_id
) VALUES (
  $1, $2
)
`

type CreateProfessorCourseAssociationParams struct {
	CourseCode  string `json:"courseCode"`
	ProfessorID int64  `json:"professorID"`
}

func (q *Queries) CreateProfessorCourseAssociation(ctx context.Context, arg CreateProfessorCourseAssociationParams) error {
	_, err := q.db.ExecContext(ctx, createProfessorCourseAssociation, arg.CourseCode, arg.ProfessorID)
	return err
}

const createProfessorRating = `-- name: CreateProfessorRating :one
INSERT INTO professor_ratings (
  quality,
  difficult,
  would_take_again,
  taken_for_credit,
  use_textbooks,
  attendance_mandatory,
  grade,
  -- tags,
  review,
  professor_id,
  course_code,
  user_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, quality, difficult, would_take_again, taken_for_credit, use_textbooks, attendance_mandatory, grade, review, up_vote, down_vote, created_at, edited_at, status, verified_date, professor_id, course_code, user_id
`

type CreateProfessorRatingParams struct {
	Quality             string `json:"quality"`
	Difficult           string `json:"difficult"`
	WouldTakeAgain      int16  `json:"wouldTakeAgain"`
	TakenForCredit      int16  `json:"takenForCredit"`
	UseTextbooks        int16  `json:"useTextbooks"`
	AttendanceMandatory int16  `json:"attendanceMandatory"`
	Grade               string `json:"grade"`
	Review              string `json:"review"`
	ProfessorID         int64  `json:"professorID"`
	CourseCode          string `json:"courseCode"`
	UserID              int64  `json:"userID"`
}

func (q *Queries) CreateProfessorRating(ctx context.Context, arg CreateProfessorRatingParams) (ProfessorRating, error) {
	row := q.db.QueryRowContext(ctx, createProfessorRating,
		arg.Quality,
		arg.Difficult,
		arg.WouldTakeAgain,
		arg.TakenForCredit,
		arg.UseTextbooks,
		arg.AttendanceMandatory,
		arg.Grade,
		arg.Review,
		arg.ProfessorID,
		arg.CourseCode,
		arg.UserID,
	)
	var i ProfessorRating
	err := row.Scan(
		&i.ID,
		&i.Quality,
		&i.Difficult,
		&i.WouldTakeAgain,
		&i.TakenForCredit,
		&i.UseTextbooks,
		&i.AttendanceMandatory,
		&i.Grade,
		&i.Review,
		&i.UpVote,
		&i.DownVote,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Status,
		&i.VerifiedDate,
		&i.ProfessorID,
		&i.CourseCode,
		&i.UserID,
	)
	return i, err
}

const createProfessorRatingTags = `-- name: CreateProfessorRatingTags :exec
INSERT INTO professor_rating_tags (
  tag_name,
  professor_rating_id
) VALUES (
  $1, $2
)
`

type CreateProfessorRatingTagsParams struct {
	TagName           string `json:"tagName"`
	ProfessorRatingID int64  `json:"professorRatingID"`
}

func (q *Queries) CreateProfessorRatingTags(ctx context.Context, arg CreateProfessorRatingTagsParams) error {
	_, err := q.db.ExecContext(ctx, createProfessorRatingTags, arg.TagName, arg.ProfessorRatingID)
	return err
}

const getProfessorRating = `-- name: GetProfessorRating :one
SELECT
  PR.id,
  PR.quality,
  PR.difficult,
  PR.would_take_again,
  PR.taken_for_credit,
  PR.use_textbooks,
  PR.attendance_mandatory,
  PR.grade,
  -- PR.tags,
  PR.review,
  P.first_name as professor_first_name,
  P.last_name as professor_last_name,
  S.name as school_name
FROM professor_ratings PR
  JOIN professors P ON PR.professor_id = P.id
  JOIN schools S ON P.school_id = S.id
WHERE P.id = $1::bigint AND PR.id = $2::bigint
`

type GetProfessorRatingParams struct {
	ProfessorID       int64 `json:"professorID"`
	ProfessorRatingID int64 `json:"professorRatingID"`
}

type GetProfessorRatingRow struct {
	ID                  int64  `json:"id"`
	Quality             string `json:"quality"`
	Difficult           string `json:"difficult"`
	WouldTakeAgain      int16  `json:"wouldTakeAgain"`
	TakenForCredit      int16  `json:"takenForCredit"`
	UseTextbooks        int16  `json:"useTextbooks"`
	AttendanceMandatory int16  `json:"attendanceMandatory"`
	Grade               string `json:"grade"`
	Review              string `json:"review"`
	ProfessorFirstName  string `json:"professorFirstName"`
	ProfessorLastName   string `json:"professorLastName"`
	SchoolName          string `json:"schoolName"`
}

func (q *Queries) GetProfessorRating(ctx context.Context, arg GetProfessorRatingParams) (GetProfessorRatingRow, error) {
	row := q.db.QueryRowContext(ctx, getProfessorRating, arg.ProfessorID, arg.ProfessorRatingID)
	var i GetProfessorRatingRow
	err := row.Scan(
		&i.ID,
		&i.Quality,
		&i.Difficult,
		&i.WouldTakeAgain,
		&i.TakenForCredit,
		&i.UseTextbooks,
		&i.AttendanceMandatory,
		&i.Grade,
		&i.Review,
		&i.ProfessorFirstName,
		&i.ProfessorLastName,
		&i.SchoolName,
	)
	return i, err
}

const listProfessorRatings = `-- name: ListProfessorRatings :many
SELECT
  PR.id,
  PR.quality,
  PR.difficult,
  PR.would_take_again,
  PR.taken_for_credit,
  PR.use_textbooks,
  PR.attendance_mandatory,
  PR.grade,
  -- PR.tags,
  PR.review,
  PR.up_vote ,
  PR.down_vote ,
  PR.created_at,
  array_agg(PRT.tag_name)::varchar[] tags
FROM professor_ratings PR
JOIN professor_rating_tags PRT ON PR.id = PRT.professor_rating_id
WHERE PR.professor_id = $1
GROUP BY PR.id
LIMIT $2
OFFSET $3
`

type ListProfessorRatingsParams struct {
	ProfessorID int64 `json:"professorID"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListProfessorRatingsRow struct {
	ID                  int64     `json:"id"`
	Quality             string    `json:"quality"`
	Difficult           string    `json:"difficult"`
	WouldTakeAgain      int16     `json:"wouldTakeAgain"`
	TakenForCredit      int16     `json:"takenForCredit"`
	UseTextbooks        int16     `json:"useTextbooks"`
	AttendanceMandatory int16     `json:"attendanceMandatory"`
	Grade               string    `json:"grade"`
	Review              string    `json:"review"`
	UpVote              int32     `json:"upVote"`
	DownVote            int32     `json:"downVote"`
	CreatedAt           time.Time `json:"createdAt"`
	Tags                []string  `json:"tags"`
}

func (q *Queries) ListProfessorRatings(ctx context.Context, arg ListProfessorRatingsParams) ([]ListProfessorRatingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfessorRatings, arg.ProfessorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProfessorRatingsRow{}
	for rows.Next() {
		var i ListProfessorRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Quality,
			&i.Difficult,
			&i.WouldTakeAgain,
			&i.TakenForCredit,
			&i.UseTextbooks,
			&i.AttendanceMandatory,
			&i.Grade,
			&i.Review,
			&i.UpVote,
			&i.DownVote,
			&i.CreatedAt,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfessorRatingsFilterByCourse = `-- name: ListProfessorRatingsFilterByCourse :many
SELECT
  PR.id,
  PR.quality,
  PR.difficult,
  PR.would_take_again,
  PR.taken_for_credit,
  PR.use_textbooks,
  PR.attendance_mandatory,
  PR.grade,
  -- PR.tags,
  PR.review,
  PR.up_vote ,
  PR.down_vote ,
  PR.created_at
FROM professor_ratings PR
WHERE PR.professor_id = $1 AND PR.course_code = $2
LIMIT $3
OFFSET $4
`

type ListProfessorRatingsFilterByCourseParams struct {
	ProfessorID int64  `json:"professorID"`
	CourseCode  string `json:"courseCode"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type ListProfessorRatingsFilterByCourseRow struct {
	ID                  int64     `json:"id"`
	Quality             string    `json:"quality"`
	Difficult           string    `json:"difficult"`
	WouldTakeAgain      int16     `json:"wouldTakeAgain"`
	TakenForCredit      int16     `json:"takenForCredit"`
	UseTextbooks        int16     `json:"useTextbooks"`
	AttendanceMandatory int16     `json:"attendanceMandatory"`
	Grade               string    `json:"grade"`
	Review              string    `json:"review"`
	UpVote              int32     `json:"upVote"`
	DownVote            int32     `json:"downVote"`
	CreatedAt           time.Time `json:"createdAt"`
}

func (q *Queries) ListProfessorRatingsFilterByCourse(ctx context.Context, arg ListProfessorRatingsFilterByCourseParams) ([]ListProfessorRatingsFilterByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfessorRatingsFilterByCourse,
		arg.ProfessorID,
		arg.CourseCode,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProfessorRatingsFilterByCourseRow{}
	for rows.Next() {
		var i ListProfessorRatingsFilterByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.Quality,
			&i.Difficult,
			&i.WouldTakeAgain,
			&i.TakenForCredit,
			&i.UseTextbooks,
			&i.AttendanceMandatory,
			&i.Grade,
			&i.Review,
			&i.UpVote,
			&i.DownVote,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfessorRatingsFilterByRating = `-- name: ListProfessorRatingsFilterByRating :many
SELECT
  PR.id,
  PR.quality,
  PR.difficult,
  PR.would_take_again,
  PR.taken_for_credit,
  PR.use_textbooks,
  PR.attendance_mandatory,
  PR.grade,
  -- PR.tags,
  PR.review,
  PR.up_vote ,
  PR.down_vote ,
  PR.created_at
FROM professor_ratings PR
WHERE PR.professor_id = $1 AND PR.quality = $2
LIMIT $3
OFFSET $4
`

type ListProfessorRatingsFilterByRatingParams struct {
	ProfessorID int64  `json:"professorID"`
	Quality     string `json:"quality"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type ListProfessorRatingsFilterByRatingRow struct {
	ID                  int64     `json:"id"`
	Quality             string    `json:"quality"`
	Difficult           string    `json:"difficult"`
	WouldTakeAgain      int16     `json:"wouldTakeAgain"`
	TakenForCredit      int16     `json:"takenForCredit"`
	UseTextbooks        int16     `json:"useTextbooks"`
	AttendanceMandatory int16     `json:"attendanceMandatory"`
	Grade               string    `json:"grade"`
	Review              string    `json:"review"`
	UpVote              int32     `json:"upVote"`
	DownVote            int32     `json:"downVote"`
	CreatedAt           time.Time `json:"createdAt"`
}

func (q *Queries) ListProfessorRatingsFilterByRating(ctx context.Context, arg ListProfessorRatingsFilterByRatingParams) ([]ListProfessorRatingsFilterByRatingRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfessorRatingsFilterByRating,
		arg.ProfessorID,
		arg.Quality,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProfessorRatingsFilterByRatingRow{}
	for rows.Next() {
		var i ListProfessorRatingsFilterByRatingRow
		if err := rows.Scan(
			&i.ID,
			&i.Quality,
			&i.Difficult,
			&i.WouldTakeAgain,
			&i.TakenForCredit,
			&i.UseTextbooks,
			&i.AttendanceMandatory,
			&i.Grade,
			&i.Review,
			&i.UpVote,
			&i.DownVote,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfessorRating = `-- name: UpdateProfessorRating :one
UPDATE professor_ratings
SET
  quality = COALESCE($1, quality),
  difficult = COALESCE($2, difficult),
  would_take_again = COALESCE($3, would_take_again),
  taken_for_credit = COALESCE($4, taken_for_credit),
  use_textbooks = COALESCE($5, use_textbooks),
  attendance_mandatory = COALESCE($6, attendance_mandatory),
  grade = COALESCE($7, grade),
  review = COALESCE($8, review),
  up_vote = COALESCE($9, up_vote),
  down_vote = COALESCE($10, down_vote),
  course_code = COALESCE($11, course_code)
WHERE
  id = $12
RETURNING id, quality, difficult, would_take_again, taken_for_credit, use_textbooks, attendance_mandatory, grade, review, up_vote, down_vote, created_at, edited_at, status, verified_date, professor_id, course_code, user_id
`

type UpdateProfessorRatingParams struct {
	Quality             sql.NullString `json:"quality"`
	Difficult           sql.NullString `json:"difficult"`
	WouldTakeAgain      sql.NullInt16  `json:"wouldTakeAgain"`
	TakenForCredit      sql.NullInt16  `json:"takenForCredit"`
	UseTextbooks        sql.NullInt16  `json:"useTextbooks"`
	AttendanceMandatory sql.NullInt16  `json:"attendanceMandatory"`
	Grade               sql.NullString `json:"grade"`
	Review              sql.NullString `json:"review"`
	UpVote              sql.NullInt32  `json:"upVote"`
	DownVote            sql.NullInt32  `json:"downVote"`
	CourseCode          sql.NullString `json:"courseCode"`
	ProfessorID         int64          `json:"professorID"`
}

func (q *Queries) UpdateProfessorRating(ctx context.Context, arg UpdateProfessorRatingParams) (ProfessorRating, error) {
	row := q.db.QueryRowContext(ctx, updateProfessorRating,
		arg.Quality,
		arg.Difficult,
		arg.WouldTakeAgain,
		arg.TakenForCredit,
		arg.UseTextbooks,
		arg.AttendanceMandatory,
		arg.Grade,
		arg.Review,
		arg.UpVote,
		arg.DownVote,
		arg.CourseCode,
		arg.ProfessorID,
	)
	var i ProfessorRating
	err := row.Scan(
		&i.ID,
		&i.Quality,
		&i.Difficult,
		&i.WouldTakeAgain,
		&i.TakenForCredit,
		&i.UseTextbooks,
		&i.AttendanceMandatory,
		&i.Grade,
		&i.Review,
		&i.UpVote,
		&i.DownVote,
		&i.CreatedAt,
		&i.EditedAt,
		&i.Status,
		&i.VerifiedDate,
		&i.ProfessorID,
		&i.CourseCode,
		&i.UserID,
	)
	return i, err
}
